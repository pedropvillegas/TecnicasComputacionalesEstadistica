---
title: "Capitulo 3"
author: "Pedro Pablo Villegas"
date: "19/9/2019"
output:
  html_document: 
    toc: yes
  pdf_document: default
editor_options:
  chunk_output_type: console
---

# VON NEUMANN

* Semilla con 5 dígitos
* Elevar al cuadrado con 10 dígitos (poner ceros iniciales si se necesita)
* Seleccionar los 5 números centrales
* Comenzar nuevamente

```{r, eval=FALSE, echo=TRUE}

vonNeumann <- function(n, semilla) {
  resultados <- numeric(length = n)
  resultados[1] <- semilla
  i <- 2
    while (i <= n) {
      resultados[i] <- 
        as.numeric(substr(
          resultados[i - 1]^2,
          nchar(resultados[i - 1]^2) - 7,
          nchar(resultados[i - 1]^2) - 3))
      i <- i + 1
    }
  return(resultados)
}

res <- vonNeumann(n = 1000, semilla = 99999)

plot(x = res[1:length(res)-1], y = res[-1], type = "p")
barplot(res[1:50])
ks.test(res[1:50], "punif")$p.value
pacf(res[1:50])
```

# GENERADOR LINEAL CONGRUENCIAL

Es un algoritmo para generar números cuasialeatorios

$$
x_{i} = ax_{i-1} + c \quad Mod \quad M, \quad para \quad i \geq1
$$

donde:

* $a$ es el multiplicador
* $c$ es el incremento
* $M$ es el módulo
* $x_{0}$ es la semilla con $x_{0} < M$

Para obtener la secuencia de números pseudo aleatorios, usamos:

$$
y_{i} = \frac{x_i}{M}
$$

El algorito empleado es de la forma:

```{r, eval=TRUE, echo=TRUE}
lcg <- function(x0, a, c, M, n){
    x <- numeric(n)
    y <- numeric(n)
    x[1] <- (a*x0 + c) %% M
    y[1] <- x[1]/M
    i <- 2
    while (i <= n) {
        x[i] <- (a*x[i - 1] + c) %% M
        y[i] <- x[i]/M
        i <- i + 1
    }
    return(list(x = x, y = y))
}
```

El período de la función `lcg()` es a lo máximo **M** y para algunas elecciones de los factores, mucho menos que eso.

# PERFORMANCE DEL GENERADOR DE NÚMEROS ALEATORIOS

Para evaluar el rendimiento del generador de números aleatorios, generalmente se chequea:

* Diagrama de dispersión de $x_{n+1}$ vs. $x_{n}$
* Prueba de Kolmogorov-Smirnov para U(0, 1) vía `ks.test`
* Explorando la función de autocorrelación parcial _PACF_ con `pacf`

## Generador Lineal Congruencial `lcg()`

```{r, eval=TRUE, echo=TRUE}

lcg.res <- lcg(5, 3, 7, 113, 226)

plot(x = lcg.res$y[1:225], y = lcg.res$y[-1], xlab = "x", ylab = "x-1")

barplot(lcg.res$y)

ks.test(lcg.res$y, 'punif')$p.value

pacf(lcg.res$y)

```

# NÚMEROS PSEUDO-ALEATORIOS Y QUASI-ALEATORIOS

Los únicos cosas que son realmente aleatorias, son las mediciones de fenómenos físicos. La única forma de simular aleatoriedad en los computadores es a través de algoritmos determinísticos. Existen dos formas para generar aleatoriedad: pseudo y quasi.

## Números pseudo-aleatorios

Los métodos pseudo-aleatorios buscan simular _aleatoriedad_

### Linear congruential generators

$$
x_n = (ax_{n-1}+c) \quad mod \quad m
$$

### Multiple recursive generators

$$
x_n = (a_{1}x_{n-1}+\ldots+a_{k}x_{n-k}c) \quad mod \quad m
$$

`runif (RNG)`

### Mersenne-Twister

`runif`

### Well equidistributed long-period linear generators

### SIMD-oriented Fast Mersenne Twister algorithms

## Números quasi-aleatorios

Los métodos quasi-aleatorios son determinísticos pero buscan estar equidistribuidos

Monte Carlo para integrar, no buscan la aleatoriedad sino una buena quidistribución, son secuencias de números.

### Van der Corput sequences

### Halton sequences

# USAR NÚMEROS ALEATORIOS PARA EVALUAR INTEGRALES

Sea $g(x)$ una función y queremos encontrar $\theta$ tal que:

$$
\theta = \int_0^1g(x)dx
$$

Si _U_ es uniformemente distribuído sobre el mismo soporte que $g(x)$, entonces podemos expresar $\theta$ como $E[g(U)]$

## Para resolver integrales entre $a$ y $b$

Si $\theta = \int_a^bg(x)dx$ con $a < b$, hacemos la siguiente sustitución:

$$
y = \frac{x-a}{b-a}
$$
$$
dy = \frac{dx}{b-a}
$$

La nueva integral es:

$$
\theta = \int_a^bg(x)dx=\int_0^1g((b-a)y+a)(b-a)d(y)=\int_0^1h(y)dy
$$

donde $h(y) = g((b-a)y+a)(b-a)$

* Evaluar la integral $\int_0^{2\pi}\sin(x)dx$ usando simulación Monte Carlo

$$
\begin{aligned}
\theta &= \int_{0}^{2\pi}\sin(x)dx \\
&= -\cos(x)\Big|_0^{2\pi} \\
&= \cos(0)-\cos(2\pi) \\
&= 1 - 1 \\
&= 0
\end{aligned}
$$


```{r, eval=TRUE, echo=TRUE}

curve(sin(x), 0, 2*pi, frame = FALSE)
abline(h = 0, col = "red", lty = 2)

a <- 0
b <- 2*pi
n <- 10000000
g <- function(x) sin(x)
h <- function(y) g(a + (b - a)*y)*(b - a)
u <- runif(n)
mean(h(u))

vab <- seq(a, b, 0.01)
v01 <- seq(0, 1, 0.01)

plot(x = vab, y = g(vab), type = "l", col = "blue", xlab = "", ylab = "",
     ylim = c(-2*pi, 2*pi), frame = FALSE)
lines(x = v01, y = h(v01), type = "l", col = "red")
abline(h = 0, col = "black", lty = 2)
legend("topright", legend = c("g(x)", "h(y)"), lty = c(1, 1),
       col = c("blue", "red"), bg = "transparent", bty = "n", cex = 0.8)

```

Evaluar la integral $\int_{\pi}^{3\pi}\cos(x)dx$ usando simulación Monte Carlo

$$
\begin{aligned}
\theta &= \int_{\pi}^{3\pi}\cos(x)dx \\
&= \sin(x)\Big|_{\pi}^{3\pi} \\
&= \sin(3\pi)-\sin(\pi) \\
&= 0 - 0 \\
&= 0
\end{aligned}
$$

```{r, eval=TRUE, echo=TRUE}

curve(cos(x), pi, 3*pi, frame = FALSE)
abline(h = 0, col = "red", lty = 2)

a <- pi
b <- 3*pi
n <- 1000000
g <- function(x) cos(x)
h <- function(y) g(a + (b - a)*y)*(b - a)
u <- runif(n)
mean(h(u))

vab <- seq(a, b, 0.01)
v01 <- seq(0, 1, 0.01)

plot(x = vab, y = g(vab), type = "l", col = "blue", xlab = "", ylab = "",
     ylim = c(-6, 6), xlim = c(0, 10), frame = FALSE)
lines(x = v01, y = h(v01), type = "l", col = "red")
abline(h = 0, col = "black", lty = 2)
legend("topright", legend = c("g(x)", "h(y)"), lty = c(1, 1),
       col = c("blue", "red"), bg = "transparent", bty = "n", cex = 0.8)

```

## Otra forma de resolver la integral entre $a$ y $b$

Generar un número aleatorio uniforme $U_{i}$ de $U(a, b)$ y luego obtener la integral usando:

$$
\theta = \int_{a}^{b}g(x)dx = (b-a)\times\sum_{i=1}^{k}\frac{g(U_{i})}{k}
$$

* Obtener la integral de $\theta = \int_{-1}^{1}e^{x+{x}^{2}}dx$ usando el método anterior

```{r, eval=TRUE, echo=TRUE}
# Primer método, cambio de límites -----------------------------------

curve(exp(x + x^2), from = -1, to = 1, frame = FALSE)
abline(v = 0)

a <- -1
b <- 1
n <- 100
g <- function(x) exp(x + x^2)
h <- function(y) g(a + y*(b - a))*(b - a)
u <- runif(n)
int.1 <- mean(h(u))
int.1

# Segundo metodo, aleatorios entre los límites -----------------------

u <- runif(n, min = a, max = b)
f <- function(x){
    exp(x + x^2)
}
int.2 <- (b - a)*mean(f(u))
int.2
```

## Resolver integrales entre $0$ e $\infty$

Si $\theta = \int_{0}^{\infty}g(x)dx$ podemos hacer el cambio de variable:

$$
\begin{gather}
y = \frac{1}{x+1} \\
dy = \frac{-dx}{(x+1)^{2}}=-y^{2}dx
\end{gather}
$$

Y obtenemos la nueva integral:

$$
\begin{aligned}
\theta &=\int_{0}^{\infty}g(x)dx \\
&= \int_{1}^{0}\frac{g(\frac{1}{y}-1)}{-y^2}dy \\
&= \int_{0}^{1}\frac{g(\frac{1}{y}-1)}{y^2}dy \\
&= \int_{0}^{1}h(y)dy
\end{aligned}
$$

Donde $h(y)=\frac{g(\frac{1}{y}-1)}{y^2}$

* $\int_{0}^{\infty}e^{-x}dx$

$$
\begin{aligned}
\theta &= \int_{0}^{\infty}e^{-x}dx \\
&= -\int_{0}^{-\infty}e^{u}du \\
&=\int_{-\infty}^{0}e^{u}du \\
&= e^{u}\Big|_{-\infty}^{0} \\
&= e^{0}-e^{-\infty} \\
&= 1 - 0 \\
&= 1
\end{aligned}
$$

```{r, eval=TRUE, echo=TRUE}

curve(exp(-x), frame = FALSE, from = -3, to = 3)
abline(v = 0)

n <- 1000
g <- function(x) exp(-x)
h <- function(y) g((1 / y) - 1)/(y^2)
u <- runif(n = n)
res <- mean(h(u))
res

vab <- seq(0, 3, 0.1)
v01 <- seq(0, 1, 0.01)

plot(x = vab, y = g(vab), type = "l", col = "blue", xlab = "", ylab = "",
     ylim = c(-2, 2), xlim = c(0, 3), frame = FALSE)
lines(x = v01, y = h(v01), type = "l", col = "red")
abline(h = 0, col = "black", lty = 2)
legend("topright", legend = c("g(x)", "h(y)"), lty = c(1, 1),
       col = c("blue", "red"), bg = "transparent", bty = "n", cex = 0.8)
abline(v = 1)
```

## Integrales entre $-\infty$ e $\infty$

* Si la función es par, la integral en el rango $(-\infty, \infty)$ es dos veces la integral en el rango $(0, \infty)$
* Si la función no es par, se debe partir el rango $(-\infty, \infty)$ en:
+ $(0, \infty)$ donde se hace el cambio de variable para $(0, 1)$
+ $(-\infty, 0)$ donde se hace el cambio de signo de $g(-x)$ para hacer el cambio de límites $(0, \infty)$ y luego hacer el reemplazo de límites a $(0, 1)$

## Integrales multidimensionales

La aproximación de integrales usando el método de Monte Carlo se hace más interesante cuando se trata de aproximar integrales multivariables.

$$
\begin{gather}
\theta = \int_{0}^{1}\int_{0}^{1}\ldots\int_{0}^{1}g(x_1, x_2, \ldots,x_n)dx_1dx_2\ldots,dx_n \\
\theta = E[g(U_1,U_2,\ldots,U_n)]
\end{gather}
$$

* Explore el efecto de $k$ en la estimación de la integral de $g(-x_1, x_2) = exp(-x_1-x_2)$ en el plano $(0, 1)\times(0, 1)$

```{r, eval=FALSE, echo=TRUE}

x <- seq(0, 1, length = 100)
y <- x
f <- function(x, y) {exp(-x-y)}
z <- outer(x, y, f)
persp(x = x, y = y, z = z, theta = 30, phi = 20, expand = 0.5, col = "lightblue", ltheta = 45, shade = 0.75, ticktype = "detailed",
      xlab = "X", ylab = "Y", zlab = "exp(-x-y)")

g <- function(x) exp(-x[1] - x[2])
k <- 5
U <- matrix(runif(n = 2*k), ncol = 2)
mean(apply(X = U, MARGIN = 1, FUN = g))

k <- c(10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000)

multi <- function(n){
    fun <- function(x) {exp(-x[1] - x[2])}
    i = 1
    for (i in 1:length(k)) {
        U <- matrix(runif(n = 2*k[i]), ncol = 2)
        resultados[i,1] <- k[i]
        resultados[i,2] <- mean(apply(X = U, MARGIN = 1, FUN = fun))
        i <- i + 1
    }
    return(resultados)
}

res <- multi(1000)

plot(x = res[,1], y = res[,2], type = "b", xlab = "k", ylab = "resultado")

?persp()
```
 
 * $\int_{0}^{1}\int_{0}^{1}xy^2dxdy$
 
```{r, eval=FALSE, echo=TRUE}
fun <- function(x) exp(x[1] * x[2]^2)
k <- 20
U <- matrix(runif(n = 2*k), ncol = 2)
mean(apply(X = U, MARGIN = 1, FUN = fun))

k <- c(10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000)

multi <- function(n){
    fun <- function(x) exp(-x[1] - x[2])
    i = 1
    for (i in 1:length(k)) {
        U <- matrix(runif(n = 2*k[i]), ncol = 2)
        resultados[i,1] <- k[i]
        resultados[i,2] <- mean(apply(X = U, MARGIN = 1, FUN = fun))
        i <- i + 1
    }
    return(resultados)
}

res <- multi(1000)

plot(x = res[,1], y = res[,2], type = "b", xlab = "k", ylab = "resultado")

?persp()
```
